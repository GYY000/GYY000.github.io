<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>first-blog</title>
    <url>/2022/12/28/first-blog/</url>
    <content><![CDATA[<p>this comes to be my first blog ever</p>
]]></content>
      <categories>
        <category>trying</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>trying</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>「BUAA-CO」P8_MIPS微系统</title>
    <url>/2022/12/30/%E3%80%8CBUAA-CO%E3%80%8DP8_MIPS%E5%BE%AE%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="P8-MIPS微系统"><a href="#P8-MIPS微系统" class="headerlink" title="P8_MIPS微系统"></a>P8_MIPS微系统</h1><p>Project7 的mips微系统在P6的流水线CPU基础上已经加入了异常以及与外界设备的交互。而P8更进一步要让我们的CPU实现能够上板验证实现一定的功能。</p>
<p>为了完成P8的实验，我们大致需要经历以下几个过程</p>
<ul>
<li>修改CPU通路</li>
<li>加入外设、调整系统桥</li>
<li>编写软件</li>
<li>上板测试</li>
</ul>
<p>下为P8模块示意图</p>
<p><img src="/P8%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<hr>
<h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><h3 id="1、CPU的构造调整"><a href="#1、CPU的构造调整" class="headerlink" title="1、CPU的构造调整"></a>1、CPU的构造调整</h3><h4 id="生成IP核"><a href="#生成IP核" class="headerlink" title="生成IP核"></a><em>生成IP核</em></h4><p>相比于之前使用的由分散寄存器构造的存储器，由IP核产生的存储器效率更高，读取更快，所以在上板验证时我们会选择使用IPcore来生成IM、DM。</p>
<p>如何生成IP核，可以参看计组的教程，生成实例可以通过产生的IP核的</p>
<p>Implementation -&gt; View HDL Instantiation Template 中的示例进行构造</p>
<p><img src="/IP%E6%A0%B8%E5%AE%9E%E4%BE%8B.png"></p>
<p>加入上述IP核后我们会面对两个问题</p>
<ul>
<li>原先存储器可以在任意周期读出，而IP核存储器只有在下一个周期才能正确读出数据</li>
</ul>
<p>为了解决这个问题，比较直接的方法就是在RegFD中将InstructionF与InstructionD两个接口短接</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> InstructionD = InstructionF;</span><br></pre></td></tr></table></figure>

<p>但是这么做存在一个问题，因为我们在P5、P6、P7中往往stall都是直接将FD寄存器的使能信号置0，保持原值，但是我们此时将 RegFD 的Instruction寄存器删除了，直接短接，但是这条被stall指令在D阶段时传回给F阶段的PC的结果往往是不确定的，也就是接入IM的i_inst_addr不是之前一条指令的pc，InstructionD自然也就不是被stall指令，因此需要进一步调整通路，来适应stall的情况</p>
<ul>
<li>调整pc或加入临时reg来解决stall</li>
</ul>
<p>笔者采用的做法是调整接入i_inst_addr的地址</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> i_inst_addr = (stallPC == <span class="number">1&#x27;b1</span>) ? pcD : pcF;</span><br></pre></td></tr></table></figure>

<p>也可以在D阶段加入一个临时的寄存器，来存储instructionD的值</p>
<h4 id="加入可综合乘除法器"><a href="#加入可综合乘除法器" class="headerlink" title="加入可综合乘除法器"></a><em>加入可综合乘除法器</em></h4><p>加入可综合乘除法器带来的不同之处就在于处理mult、div运算时busy的方法。</p>
<p>乘除法器接口如下</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MulDivUnit(</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> clk,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> reset,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] in_src0,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] in_src1,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] in_op,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> in_sign,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">wire</span> in_ready,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> in_valid,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> out_ready,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">wire</span> out_valid,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] out_res0,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] out_res1)</span><br></pre></td></tr></table></figure>

<p>我们只需要稍微在 outvalid &#x3D; 1 时让busy_reg下一周期变0 即可产生正确的逻辑（下为部分代码，仅供参考）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> in_valid;</span><br><span class="line"><span class="keyword">reg</span> busy_in;</span><br><span class="line">	 </span><br><span class="line"><span class="keyword">wire</span> out_valid;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] out_res0;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] out_res1;</span><br><span class="line"><span class="keyword">wire</span> in_ready;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(Req != <span class="number">1&#x27;b1</span> &amp;&amp; start == <span class="number">1&#x27;b1</span> &amp;&amp; in_ready == <span class="number">1&#x27;b1</span> &amp;&amp; (hiloMode == `multuMode || hiloMode == `multMode)) </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	in_op &lt;= <span class="number">2&#x27;b01</span>;</span><br><span class="line">	in_valid &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	busy_in &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Req != <span class="number">1&#x27;b1</span> &amp;&amp; start == <span class="number">1&#x27;b1</span> &amp;&amp; in_ready == <span class="number">1&#x27;b1</span> &amp;&amp; (hiloMode == `divuMode || hiloMode == `divMode)) </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	in_op &lt;= <span class="number">2&#x27;b10</span>;</span><br><span class="line">	in_valid &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	busy_in &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(out_valid == <span class="number">1&#x27;d1</span>) </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	in_valid &lt;= <span class="number">0</span>;</span><br><span class="line">	in_op &lt;= <span class="number">0</span>;</span><br><span class="line">	busy_in &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	HI &lt;= out_res1;</span><br><span class="line">	LO &lt;= out_res0;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">assign</span> busy = busy_in;</span><br></pre></td></tr></table></figure>

<h3 id="2、外设的加入"><a href="#2、外设的加入" class="headerlink" title="2、外设的加入"></a>2、外设的加入</h3><p><img src="/fpga%E5%AE%9E%E4%BE%8B.png"></p>
<h3 id="3、软件编写"><a href="#3、软件编写" class="headerlink" title="3、软件编写"></a>3、软件编写</h3><p>课下实现的任务时：串口回显 + 正数或倒数计时 + </p>
<p>课上实现的任务为：</p>
<h2 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h2>]]></content>
      <categories>
        <category>计算机组成及其原理</category>
      </categories>
      <tags>
        <tag>计算机组成及其原理</tag>
        <tag>mips</tag>
        <tag>上机实验</tag>
      </tags>
  </entry>
</search>
