<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/28/first-blog/</url>
    <content><![CDATA[<blockquote>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a><em><strong>Hello World</strong></em></h2></blockquote>
<p>从打出第一句C语言的“Hello world”，到如今完成计组的全部project，在秃头的路上已经走过了一年半载。</p>
<p>搭建这个博客的起因是希望能记录一下自己这一个学期计组跌宕起伏的学习历程，品尝过挂P的滋味，也感受过通关P8的喜悦。同时我也希望自己的计组课程经历能对接下来挑战他的大家有所帮助，少走一点弯弯绕绕。</p>
<p>另一方面也想在博客里继续记录自己今后几年的计院生活，给自己的大学四年，留下一点痕迹。</p>
]]></content>
      <categories>
        <category>纪念</category>
      </categories>
      <tags>
        <tag>纪念</tag>
      </tags>
  </entry>
  <entry>
    <title>「BUAA-CO」P8_MIPS微系统</title>
    <url>/2022/12/30/%E3%80%8CBUAA-CO%E3%80%8DP8_MIPS%E5%BE%AE%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>P7 的mips微系统在P6的流水线CPU基础上已经加入了异常监测以及与外界设备交互两个功能。而P8更进一步要让我们的CPU能够上板验证并且编写软件来实现题目要求的一定功能。</p>
<p>为了完成P8的实验，我们大致需要经历以下几个过程</p>
<ul>
<li>修改CPU通路</li>
<li>加入外设、调整系统桥</li>
<li>编写软件</li>
<li>上板测试</li>
</ul>
<p><img src="/post-image/P8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="P8模块示意图"></p>
<hr>
<h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><h3 id="1、CPU的构造调整"><a href="#1、CPU的构造调整" class="headerlink" title="1、CPU的构造调整"></a>1、CPU的构造调整</h3><h4 id="生成IP核"><a href="#生成IP核" class="headerlink" title="生成IP核"></a><em>生成IP核</em></h4><p>相比于之前使用的由分散寄存器构造的存储器，由IP核产生的存储器效率更高，读取更快，所以在上板验证时我们会选择使用IPcore来生成IM、DM。</p>
<p>如何生成IP核，可以参看计组的教程，生成实例可以通过产生的IP核的</p>
<p>Implementation -&gt; View HDL Instantiation Template 中的示例进行构造</p>
<p><img src="/post-image/IP%E6%A0%B8%E5%AE%9E%E4%BE%8B.png"></p>
<p>加入上述IP核后我们会面对两个问题</p>
<ul>
<li>原先存储器可以在任意周期读出，而IP核存储器只有在下一个周期才能正确读出数据</li>
</ul>
<p>为了解决这个问题，比较直接的方法就是在RegFD中将InstructionF与InstructionD两个接口短接</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> InstructionD = InstructionF;</span><br></pre></td></tr></table></figure>

<p>但是这么做存在一个问题，因为我们在P5、P6、P7中往往stall都是直接将FD寄存器的使能信号置0，保持原值，但是我们此时将 RegFD 的Instruction寄存器删除了，直接短接，但是这条被stall指令在D阶段时传回给F阶段的PC的结果往往是不确定的，也就是接入IM的i_inst_addr不是之前一条指令的pc，InstructionD自然也就不是被stall指令，因此需要进一步调整通路，来适应stall的情况</p>
<ul>
<li>调整pc或加入临时reg来解决stall</li>
</ul>
<p>笔者采用的做法是调整接入i_inst_addr的地址</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> i_inst_addr = (stallPC == <span class="number">1&#x27;b1</span>) ? pcD : pcF;</span><br></pre></td></tr></table></figure>

<p>也可以在D阶段加入一个临时的寄存器，来存储instructionD的值</p>
<h5 id="coe生成器"><a href="#coe生成器" class="headerlink" title="coe生成器"></a><em>coe生成器</em></h5><p>IP核中的IM ROM 需要使用coe文件初始化（coe文件的格式可以参考教程），因此需要一个用来将mars导出代码转为coe文件的转换器，下面是我当时写的coe文件生成器</p>
<p><em>使用方法将 handler.txt、code.txt与代码文件放在同一个文件夹下，运行即得testcode.coe文件，再导入IM即可</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max = (<span class="number">0x4180</span> - <span class="number">0x3000</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE* coe = <span class="built_in">fopen</span>(<span class="string">&quot;testcode.coe&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">	FILE* code =<span class="built_in">fopen</span>(<span class="string">&quot;code.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	FILE* handler = <span class="built_in">fopen</span>(<span class="string">&quot;handler.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(coe,<span class="string">&quot;memory_initialization_radix=16;\nmemory_initialization_vector=\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">fgets</span>(str,<span class="number">100</span>,code)!= <span class="literal">NULL</span> &amp;&amp; str[<span class="number">0</span>] != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(str); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(str[j] == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">				str[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fprintf</span>(coe,<span class="string">&quot;%s,\n&quot;</span>,str);</span><br><span class="line">		count = count + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(;count &lt; max<span class="number">-1</span>;count++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(coe,<span class="string">&quot;00000000,\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(count &lt; max)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(coe,<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">fgets</span>(str,<span class="number">100</span>,handler)!= <span class="literal">NULL</span> &amp;&amp; str[<span class="number">0</span>] != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(coe,<span class="string">&quot;,\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(str); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(str[j] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				str[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fprintf</span>(coe,<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fprintf</span>(coe,<span class="string">&quot;;&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="加入可综合乘除法器"><a href="#加入可综合乘除法器" class="headerlink" title="加入可综合乘除法器"></a><em>加入可综合乘除法器</em></h4><p>P7使用的除法和取模运算是不能综合的，所以需要替换为可综合的乘除法器。</p>
<p>加入可综合乘除法器带来的不同之处就在于处理mult、div运算时busy的方法。</p>
<p>乘除法器接口如下</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MulDivUnit(</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> clk,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> reset,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] in_src0,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] in_src1,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] in_op,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> in_sign,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">wire</span> in_ready,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> in_valid,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> out_ready,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">wire</span> out_valid,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] out_res0,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] out_res1)</span><br></pre></td></tr></table></figure>

<p>我们只需要在 outvalid &#x3D; 1 时让busy_reg下一周期变0 即可产生正确的逻辑（下为部分代码，仅供参考）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> in_valid;</span><br><span class="line"><span class="keyword">reg</span> busy_in;</span><br><span class="line">	 </span><br><span class="line"><span class="keyword">wire</span> out_valid;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] out_res0;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] out_res1;</span><br><span class="line"><span class="keyword">wire</span> in_ready;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(Req != <span class="number">1&#x27;b1</span> &amp;&amp; start == <span class="number">1&#x27;b1</span> &amp;&amp; in_ready == <span class="number">1&#x27;b1</span> &amp;&amp; (hiloMode == `multuMode || hiloMode == `multMode)) </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	in_op &lt;= <span class="number">2&#x27;b01</span>;</span><br><span class="line">	in_valid &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	busy_in &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Req != <span class="number">1&#x27;b1</span> &amp;&amp; start == <span class="number">1&#x27;b1</span> &amp;&amp; in_ready == <span class="number">1&#x27;b1</span> &amp;&amp; (hiloMode == `divuMode || hiloMode == `divMode)) </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	in_op &lt;= <span class="number">2&#x27;b10</span>;</span><br><span class="line">	in_valid &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	busy_in &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(out_valid == <span class="number">1&#x27;d1</span>) </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	in_valid &lt;= <span class="number">0</span>;</span><br><span class="line">	in_op &lt;= <span class="number">0</span>;</span><br><span class="line">	busy_in &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	HI &lt;= out_res1;</span><br><span class="line">	LO &lt;= out_res0;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">assign</span> busy = busy_in;</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a><em>其他</em></h4><p>其他调整就是CPU输出一个read_en信号用来表示CPU此时有一条load语句正在读取，read_en将用于uart rx_clear的判断（后面会讲到）。</p>
<h3 id="2、外设的加入"><a href="#2、外设的加入" class="headerlink" title="2、外设的加入"></a>2、外设的加入</h3><p><img src="/post-image/fpga%E5%AE%9E%E4%BE%8B.png"></p>
<h4 id="软件对外设操作枚举"><a href="#软件对外设操作枚举" class="headerlink" title="软件对外设操作枚举"></a><em>软件对外设操作枚举</em></h4><ul>
<li><p>调整波特率 </p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sw </span>Reg,<span class="number">0x7f38</span>($<span class="number">0</span>) </span><br><span class="line"><span class="keyword">sw </span>Reg,<span class="number">0x7f3c</span>($<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得两组拨码开关的值 </p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lw </span>$<span class="built_in">s0</span>,<span class="number">0x7f60</span>($<span class="number">0</span>) </span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">s1</span>,<span class="number">0x7f64</span>($<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得按键开关的值  </p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lw </span>$<span class="built_in">s2</span>,<span class="number">0x7f68</span>($<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>调整LED </p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sw </span>Reg,<span class="number">0x7f70</span>($<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出给UART </p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sb </span>Reg,<span class="number">7</span>f33($<span class="number">0</span>) </span><br><span class="line"><span class="keyword">sw </span>Reg,<span class="number">7</span>f30($<span class="number">0</span>) </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="LED、按键开关、拨码开关和数码管"><a href="#LED、按键开关、拨码开关和数码管" class="headerlink" title="LED、按键开关、拨码开关和数码管"></a><em>LED</em>、按键开关、拨码开关和数码管</h4><p>这四个外设的实现比较简单，数码管的发光原理可以参看计组的教程，上面写的比较详细，单管的代码直接引用教程中源代码即可。</p>
<h4 id="uart"><a href="#uart" class="headerlink" title="uart"></a><em>uart</em></h4><p><em>个人当时遇到的比较大的麻烦是uart的处理</em></p>
<p>关于uart的接受与发送原理我这里也不再过多赘述，教程与网上都有解释</p>
<p>我个人是首先实现了四个寄存器Data存储传输和接受的数据 LSR [5]存储了此时的发送空闲情况，LSR[0] 存储了此时的读取成功情况， DIVR DIVT存储tx和rx的传输所需周期数</p>
<p><em>tx与rx的代码可以直接引用计组网站中写好了的源码</em></p>
<p><em><strong>我个人对uart进行了一点小小的改进，让他能够支持sw 和 sb两种模式，也就是引入bitcount，bitcount &gt; 0 的时候说明还有字节没有发送 所以tx_start保持为1，发送的有效情况是bitcount &gt; 0 并且 tx_avai 此时要Data右移八位，并且bitcount -&#x3D; 1</strong></em></p>
<p>需要改进点：</p>
<ol>
<li>我这样的代码其实sw的时候 先输出的会是低字节 也就是 0x12 34 56 78 我会输出为 78 56 34 12；</li>
<li>我的uart仍然存在bug似乎会在sb、sw混用时产生问题；</li>
<li>UART传输计算器结果时，如果rx正好读入，也会产生问题</li>
</ol>
<p>但这往往不会发生，因为时间差太大，除非尝试同时改动开关按钮，并且从UART输入，不然在一秒钟的时间之内cpu已经执行完25M条指令，极少会出现撞车的情况。</p>
<p>仅在此提供一点自己的思路供大家参考！</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">UART uart(</span><br><span class="line">    <span class="variable">.clk</span>(clk_in),</span><br><span class="line">    <span class="variable">.rstn</span>(sys_rstn),</span><br><span class="line">    <span class="variable">.byteen</span>(UARTbyteen),</span><br><span class="line">    <span class="variable">.addr</span>(m_data_addr),</span><br><span class="line">    <span class="variable">.data_in</span>(m_data_wdata),</span><br><span class="line">    <span class="variable">.rx_clear</span>(rx_clear),<span class="comment">// 从bridge中接出来</span></span><br><span class="line">	 <span class="variable">.rx_ready</span>(rx_ready),</span><br><span class="line">    <span class="variable">.UARTInt</span>(UARTInt),</span><br><span class="line">    <span class="variable">.uart_rxd</span>(uart_rxd),</span><br><span class="line">    <span class="variable">.UART_out</span>(UARTRead),</span><br><span class="line">    <span class="variable">.uart_txd</span>(uart_txd)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// module define</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> Data uart_reg[0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> LSR uart_reg[1]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DIVR uart_reg[2]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DIVT uart_reg[3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> UART (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rstn,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] byteen,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] addr,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] data_in,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rx_clear,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> uart_rxd,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span> UARTInt,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> rx_ready,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] UART_out,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> uart_txd</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] uart_reg[<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] rx_data;</span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] bitcount;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rstn)<span class="keyword">begin</span></span><br><span class="line">            uart_reg[<span class="number">0</span>] &lt;= <span class="number">32&#x27;b0</span>;</span><br><span class="line">            uart_reg[<span class="number">1</span>] &lt;= <span class="number">32&#x27;b0</span>;</span><br><span class="line">            uart_reg[<span class="number">2</span>] &lt;= <span class="number">32&#x27;b0</span>;</span><br><span class="line">            uart_reg[<span class="number">3</span>] &lt;= <span class="number">32&#x27;b0</span>;</span><br><span class="line">			bitcount &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(byteen != <span class="number">0</span>)<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span> (byteen[<span class="number">3</span>]) uart_reg[addr[<span class="number">3</span>:<span class="number">2</span>]][<span class="number">31</span>:<span class="number">24</span>] &lt;= data_in[<span class="number">31</span>:<span class="number">24</span>];<span class="keyword">else</span> <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line">				<span class="keyword">if</span> (byteen[<span class="number">2</span>]) uart_reg[addr[<span class="number">3</span>:<span class="number">2</span>]][<span class="number">23</span>:<span class="number">16</span>] &lt;= data_in[<span class="number">23</span>:<span class="number">16</span>];<span class="keyword">else</span> <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line">				<span class="keyword">if</span> (byteen[<span class="number">1</span>]) uart_reg[addr[<span class="number">3</span>:<span class="number">2</span>]][<span class="number">15</span>:<span class="number">8</span>] &lt;= data_in[<span class="number">15</span>:<span class="number">8</span>];<span class="keyword">else</span> <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line">				<span class="keyword">if</span> (byteen[<span class="number">0</span>]) uart_reg[addr[<span class="number">3</span>:<span class="number">2</span>]][ <span class="number">7</span>:<span class="number">0</span>] &lt;= data_in[<span class="number">7</span>:<span class="number">0</span>];<span class="keyword">else</span> <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">if</span>(addr[<span class="number">3</span>:<span class="number">2</span>] == <span class="number">2&#x27;b00</span>) bitcount &lt;= byteen[<span class="number">0</span>] +byteen[<span class="number">1</span>] + byteen[<span class="number">2</span>] +byteen[<span class="number">3</span>];<span class="keyword">else</span> <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                `LSR[<span class="number">5</span>] &lt;= (bitcount == <span class="number">4&#x27;b0000</span>);</span><br><span class="line">                `LSR[<span class="number">0</span>] &lt;= rx_ready;</span><br><span class="line">                <span class="keyword">if</span>(rx_ready)<span class="keyword">begin</span></span><br><span class="line">                    `Data[<span class="number">7</span>:<span class="number">0</span>] &lt;= rx_data;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(bitcount &gt; <span class="number">0</span> &amp;&amp; tx_avai)<span class="keyword">begin</span></span><br><span class="line">					`Data &lt;= &#123;<span class="number">8&#x27;b0</span>,`Data[<span class="number">31</span>:<span class="number">8</span>]&#125;;</span><br><span class="line">					bitcount &lt;= bitcount - <span class="number">4&#x27;b1</span>;</span><br><span class="line">				<span class="keyword">end</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">assign</span> tx_start = bitcount &gt; <span class="number">0</span>;</span><br><span class="line">    uart_tx tx (</span><br><span class="line">        <span class="variable">.clk</span>(clk), <span class="variable">.rstn</span>(rstn), <span class="variable">.period</span>(`DIVT[<span class="number">15</span>:<span class="number">0</span>]), <span class="variable">.txd</span>(uart_txd), </span><br><span class="line">        <span class="variable">.tx_start</span>(tx_start), <span class="variable">.tx_data</span>(`Data[<span class="number">7</span>:<span class="number">0</span>]), <span class="variable">.tx_avai</span>(tx_avai)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    uart_rx rx(</span><br><span class="line">        <span class="variable">.clk</span>(clk), <span class="variable">.rstn</span>(rstn), <span class="variable">.period</span>(`DIVR[<span class="number">15</span>:<span class="number">0</span>]), <span class="variable">.rxd</span>(uart_rxd),</span><br><span class="line">        <span class="variable">.rx_clear</span>(rx_clear), <span class="variable">.rx_data</span>(rx_data), <span class="variable">.rx_ready</span>(rx_ready)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> UARTInt = rx_ready;</span><br><span class="line">    <span class="keyword">assign</span> UART_out = (addr[<span class="number">3</span>:<span class="number">2</span>] == <span class="number">2&#x27;b00</span>) ? `Data:</span><br><span class="line">    (addr[<span class="number">3</span>:<span class="number">2</span>] == <span class="number">2&#x27;b01</span>) ? `LSR: </span><br><span class="line">    (addr[<span class="number">3</span>:<span class="number">2</span>] == <span class="number">2&#x27;b10</span>) ? `DIVR:</span><br><span class="line">    (addr[<span class="number">3</span>:<span class="number">2</span>] == <span class="number">2&#x27;b11</span>) ? `DIVT : <span class="number">32&#x27;d0</span>;   </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a><em>Bridge</em></h4><p>Bridge需要完成的任务：</p>
<ul>
<li>地址判断，根据地址判断的情况给各个外设发布允许写入信号</li>
<li>实现多路选择器，选择读回给到CPU的数据</li>
<li>处理HWInt</li>
<li>处理rx_clear的判断，rx_clear应该是在 rx_ready &#x3D;&#x3D; 1也就是已经读取完成，并且 load 读取的UART内容也就是（read_en &amp;&amp; addr &#x3D;&#x3D; &#96;UART_addrb）时置1</li>
</ul>
<p>下面是我的源代码，供大家参考</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Bridge(</span><br><span class="line"><span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] addr,</span><br><span class="line"><span class="keyword">input</span> UARTInt,</span><br><span class="line"><span class="keyword">input</span> IRQ_timer,</span><br><span class="line"><span class="keyword">input</span> read_en,</span><br><span class="line"><span class="keyword">input</span> rx_ready,</span><br><span class="line"><span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] byteen,</span><br><span class="line"><span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] DMRead,</span><br><span class="line"><span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] TimerRead,</span><br><span class="line"><span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] ButtonSwitchRead,</span><br><span class="line"><span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] DIPSwitchRead,</span><br><span class="line"><span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] UARTRead,</span><br><span class="line"><span class="keyword">output</span> DMWrite,</span><br><span class="line"><span class="keyword">output</span> timerWrite,</span><br><span class="line"><span class="keyword">output</span> LEDWrite,</span><br><span class="line"><span class="keyword">output</span> DigitTubeWrite,</span><br><span class="line"><span class="keyword">output</span> UARTWrite,</span><br><span class="line"><span class="keyword">output</span> rx_clear,</span><br><span class="line"><span class="keyword">output</span> [<span class="number">5</span>:<span class="number">0</span>] HWInt,</span><br><span class="line"><span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] ReadData</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> rx_clear = (read_en &amp;&amp; addr == `UART_addrb) &amp; rx_ready;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> inTC = (addr &gt;= `Timer_addrb &amp;&amp; addr &lt;= `Timer_addre) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">wire</span> inDM  = (addr &gt;= <span class="number">32&#x27;h00000000</span> &amp;&amp; addr &lt;= <span class="number">32&#x27;h00002fff</span>) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">wire</span> inUART =  (addr &gt;= `UART_addrb &amp;&amp; addr &lt;= `UART_addre) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">wire</span> inDigitTube =  (addr &gt;= `DigitTube_addrb &amp;&amp; addr &lt;= `DigitTube_addre) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">wire</span> inDipSwitch =  (addr &gt;= `DipSwitch_addrb &amp;&amp; addr &lt;= `DipSwitch_addre) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">wire</span> inButtonSwitch =  (addr &gt;= `ButtonSwitch_addrb &amp;&amp; addr &lt;= `ButtonSwitch_addre) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">wire</span> inLED =  (addr &gt;= `LED_addrb &amp;&amp; addr &lt;= `LED_addre) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> DMWrite = (inDM &amp;&amp; (|byteen != <span class="number">0</span>)) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">assign</span> timerWrite = (inTC &amp;&amp; (|byteen != <span class="number">0</span>)) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">assign</span> LEDWrite = (inLED &amp;&amp; (|byteen != <span class="number">0</span>)) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">assign</span> DigitTubeWrite = (inDigitTube &amp;&amp; (|byteen != <span class="number">0</span>)) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">assign</span> UARTWrite = (inUART &amp;&amp; (|byteen != <span class="number">0</span>)) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> HWInt = &#123;<span class="number">2&#x27;b0</span>,UARTInt,<span class="number">2&#x27;b0</span>,IRQ_timer&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> ReadData =   (inDM) ? DMRead:</span><br><span class="line"> (inTC) ? TimerRead: </span><br><span class="line">(inUART) ? UARTRead: </span><br><span class="line">(inButtonSwitch) ? ButtonSwitchRead:</span><br><span class="line">(inDipSwitch)? DIPSwitchRead: <span class="number">32&#x27;d0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="3、软件编写"><a href="#3、软件编写" class="headerlink" title="3、软件编写"></a>3、软件编写</h3><h4 id="课下实现的任务："><a href="#课下实现的任务：" class="headerlink" title="课下实现的任务："></a>课下实现的任务：</h4><ol>
<li>UART串口回显</li>
<li>正数、倒数计时 + 计算器</li>
<li>显示模式切换</li>
</ol>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><em>初始化</em></h5><p>在初始化部分主要是几个地方，直接看代码理解一下吧</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">#init</span></span><br><span class="line"><span class="comment">#初始化波特率 对应于2604（2604的算法可以参看教程）</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">1</span>,$<span class="number">1</span>,<span class="number">2604</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>,<span class="number">0x7f38</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>,<span class="number">0x7f3c</span>($<span class="number">0</span>)</span><br><span class="line"><span class="comment">#timer</span></span><br><span class="line"><span class="comment">#初始化时钟 fpga使用的时钟频率为25MHz</span></span><br><span class="line"><span class="comment">#在时钟初值处存入25000000</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="number">1</span>,<span class="number">0x17d</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">1</span>,$<span class="number">1</span>,<span class="number">0x7840</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>,<span class="number">0x7f04</span>($<span class="number">0</span>)</span><br><span class="line"><span class="comment">#允许时钟和timer的中断</span></span><br><span class="line"><span class="keyword">addi </span>$<span class="number">1</span>,$<span class="number">0</span>,<span class="number">0xfc01</span></span><br><span class="line"><span class="keyword">mtc0 </span>$<span class="number">1</span>,$<span class="number">12</span></span><br></pre></td></tr></table></figure>

<h5 id="循环程序"><a href="#循环程序" class="headerlink" title="循环程序"></a><em>循环程序</em></h5><p>fpga内的程序代码与我们平时的mips程序的区别就是他是一个无限循环的过程，模仿我们的操作系统，不停的查询有没有操作。</p>
<p>主体结构大概是</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="symbol">init:</span></span><br><span class="line">&lt;init code&gt;</span><br><span class="line"><span class="symbol">init_end:</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">program:</span></span><br><span class="line">&lt;code&gt;</span><br><span class="line"><span class="symbol">program_end:</span></span><br><span class="line"><span class="keyword">j </span>program</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol"></span></span><br><span class="line"><span class="symbol">handler:</span></span><br><span class="line">&lt;handler code&gt;</span><br><span class="line"><span class="keyword">eret</span></span><br></pre></td></tr></table></figure>

<h5 id="程序开头"><a href="#程序开头" class="headerlink" title="程序开头"></a><em>程序开头</em></h5><p>我个人在程序开头加入了一段程序，来避免反复启动后续的计算器和计时器程序，这样的好处是可以避免运算器和计时器结果反复传输给UART，以及反复给计时器赋初值，重新计时。</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读入拨码开关与按键开关值</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">s0</span>,<span class="number">0x7f60</span>($<span class="number">0</span>) </span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">s1</span>,<span class="number">0x7f64</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">s2</span>,<span class="number">0x7f68</span> ($<span class="number">0</span>)</span><br><span class="line"><span class="comment">#与之前值进行比较</span></span><br><span class="line"><span class="keyword">sub </span>$<span class="built_in">t0</span>,$<span class="built_in">s0</span>,$<span class="built_in">s3</span></span><br><span class="line"><span class="keyword">sub </span>$<span class="built_in">t1</span>,$<span class="built_in">s1</span>,$<span class="built_in">s4</span></span><br><span class="line"><span class="keyword">sub </span>$<span class="built_in">t2</span>,$<span class="built_in">s2</span>,$<span class="built_in">s5</span></span><br><span class="line"><span class="keyword">or </span>$<span class="built_in">t0</span>,$<span class="built_in">t0</span>,$<span class="built_in">t1</span></span><br><span class="line"><span class="keyword">or </span>$<span class="built_in">t0</span>,$<span class="built_in">t0</span>,$<span class="built_in">t2</span></span><br><span class="line"><span class="comment">#s3 s4 s5分别保存上一次的拨码开关1、拨码开关2、按键开关的值</span></span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">s3</span>,$<span class="built_in">s0</span>,$<span class="number">0</span></span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">s4</span>,$<span class="built_in">s1</span>,$<span class="number">0</span></span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">s5</span>,$<span class="built_in">s2</span>,$<span class="number">0</span></span><br><span class="line"><span class="comment">#本次查询与上次查询所获得拨码开关与按键开关值相同则调到结尾 开始下一轮</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,program_out</span><br><span class="line"><span class="keyword">nop</span></span><br></pre></td></tr></table></figure>

<h5 id="串口回显"><a href="#串口回显" class="headerlink" title="串口回显"></a><em>串口回显</em></h5><p>串口回显使用中断实现，一旦发生串口收到消息引起的中断，就执行读取、输出串口读入值</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">.ktext <span class="number">0x4180</span></span><br><span class="line"><span class="keyword">mfc0 </span>$<span class="built_in">k0</span>,$<span class="number">12</span></span><br><span class="line"><span class="keyword">mfc0 </span>$<span class="built_in">k1</span>,$<span class="number">13</span></span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t8</span>,$<span class="built_in">k1</span>,<span class="number">0x2000</span> <span class="comment">#UART interupt 0010 0000 0000 0000</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t8</span>,$<span class="number">0</span>,Timer_int <span class="comment">#if !uart interupt then branch</span></span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#######################################</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">t8</span>,<span class="number">0x7f30</span>($<span class="number">0</span>)<span class="comment">#read in UART</span></span><br><span class="line"><span class="symbol">uart_wait3:</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">a3</span>,<span class="number">0x7F34</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">a3</span>,$<span class="built_in">a3</span>,<span class="number">0x0020</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">a3</span>,$<span class="number">0</span>,uart_wait3</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">sb </span>$<span class="built_in">t8</span>,<span class="number">0x7f33</span>($<span class="number">0</span>)<span class="comment">#write to UART</span></span><br><span class="line"><span class="comment">########################################</span></span><br><span class="line">Timer_int</span><br></pre></td></tr></table></figure>

<h5 id="正数倒数计时"><a href="#正数倒数计时" class="headerlink" title="正数倒数计时"></a><em>正数倒数计时</em></h5><p>计时器的实现需要运用到timer，具体步骤如下，启动timer，timer由于之前赋了初值25M，所以相当于一次中断算一秒，中断一次，重新输出一次</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">#大致思路如下 就不贴源代码了 大家可以自由发挥</span></span><br><span class="line"><span class="comment">#根据按键开关值判断模式</span></span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t0</span>,$<span class="built_in">s2</span>,<span class="number">0x0001</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,Calculator</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#打开timer</span></span><br><span class="line"><span class="comment">#open timer</span></span><br><span class="line"><span class="keyword">addi </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,<span class="number">0x0009</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">t0</span>,<span class="number">0x7f00</span>($<span class="number">0</span>)</span><br><span class="line"><span class="comment">#根据按键开关判断是正数还是倒数</span></span><br><span class="line">&lt;Your code&gt;</span><br><span class="line"><span class="comment">#给一个寄存器赋结束值（下面称为终值寄存器） 一个寄存器赋初值（下面称为初值寄存器）</span></span><br><span class="line"><span class="comment">#这三个寄存器不要被其他与timer段无关的程序代码使用 </span></span><br><span class="line">&lt;Your code&gt;</span><br><span class="line"><span class="comment">#最后输出</span></span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t0</span>,$<span class="built_in">s2</span>,<span class="number">0x0002</span></span><br><span class="line"><span class="keyword">slt </span>$<span class="built_in">a0</span>,$<span class="number">0</span>,$<span class="built_in">t0</span> <span class="comment">#a0 = 0  数码管 a0 = 1 uart</span></span><br><span class="line"><span class="keyword">jal </span>output</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment">#异常处理程序</span></span><br><span class="line"><span class="comment">#判断是否是timerint</span></span><br><span class="line"><span class="symbol">Timer_int:</span></span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t8</span>,$<span class="built_in">k1</span>,<span class="number">0x0400</span> <span class="comment">#Timer interupt 0000 0100 0000 0000</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t8</span>,$<span class="number">0</span>,end_exc</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#根据是否达到终值判断是否open timer</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="keyword">begin,$end,nopen</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">addi </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,<span class="number">0x0009</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">t0</span>,<span class="number">0x7f00</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">nopen:</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#如果初值终值不等 根据状态值执行 初值寄存器+1 或者 -1</span></span><br><span class="line">&lt;Your code&gt;</span><br><span class="line"><span class="comment">#输出 同上</span></span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t0</span>,$<span class="built_in">s2</span>,<span class="number">0x0002</span></span><br><span class="line"><span class="keyword">slt </span>$<span class="built_in">a0</span>,$<span class="number">0</span>,$<span class="built_in">t0</span> <span class="comment">#a0 = 0  数码管 a0 = 1 uart</span></span><br><span class="line"><span class="keyword">jal </span>output</span><br><span class="line"><span class="keyword">nop</span></span><br></pre></td></tr></table></figure>

<h5 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a><em>计算器</em></h5><p>计算器就比较简单，直接看一下范例理解一下就好</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Calculator:</span> <span class="comment">#use $t5 as result</span></span><br><span class="line"><span class="keyword">add_tag:</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">andi </span>$<span class="built_in">t0</span>,$<span class="built_in">s2</span>,<span class="number">0x0004</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,<span class="keyword">sub_tag</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">add </span>$<span class="built_in">t5</span>,$<span class="built_in">s0</span>,$<span class="built_in">s1</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="number">0</span>,$<span class="number">0</span>,cal_out</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>&lt;······· 其他运算 ······· &gt;</span><br><span class="line"><span class="comment">#######Out##############</span></span><br><span class="line">cal_out：</span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t0</span>,$<span class="built_in">s2</span>,<span class="number">0x0002</span></span><br><span class="line"><span class="keyword">slt </span>$<span class="built_in">a0</span>,$<span class="number">0</span>,$<span class="built_in">t0</span> <span class="comment">#a0 = 0  数码管 a0 = 1 uart</span></span><br><span class="line"><span class="keyword">jal </span>output</span><br><span class="line"><span class="keyword">nop</span></span><br></pre></td></tr></table></figure>

<h5 id="显示模式切换"><a href="#显示模式切换" class="headerlink" title="显示模式切换"></a><em>显示模式切换</em></h5><p>只需要使用一个beq语句即可</p>
<p>根据传送过来的a0的情况,来判断怎么输出即可</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="symbol">output:</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">a0</span>,$<span class="number">0</span>,tubeOut</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">uartOut:</span></span><br><span class="line"><span class="symbol">uart_wait:</span><span class="comment">#等uart不繁忙的时候再输出</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">t0</span>,<span class="number">0x7F34</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t0</span>,$<span class="built_in">t0</span>,<span class="number">0x0020</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,uart_wait</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">sw </span>$<span class="built_in">t5</span>,<span class="number">0x7f30</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">beq </span>$<span class="number">0</span>,$<span class="number">0</span>,endOut</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">tubeOut:</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">t5</span>,<span class="number">0x7f50</span>($<span class="number">0</span>)</span><br><span class="line"><span class="symbol">endOut:</span></span><br><span class="line"><span class="keyword">jr </span>$<span class="built_in">ra</span></span><br><span class="line"><span class="keyword">nop</span></span><br></pre></td></tr></table></figure>

<p>这样写其实仍然有点小问题，比如如何更好的在计时器和计算器中切换，因为上面的代码并没有办法停止计时器，他仍然会执行完整个初值到终值的过程，大家可以自己思考一下。</p>
<h4 id="课上实现的任务："><a href="#课上实现的任务：" class="headerlink" title="课上实现的任务："></a>课上实现的任务：</h4><ol>
<li><p>利用后四个键实现加减乘除四个运算模式。过一秒钟，如果按键不改变就以上一次结果为操作数1与第二个操作数继续运算</p>
</li>
<li><p>结果是偶数就uart输出，奇数就数码管输出</p>
</li>
<li><p>uart输入D程序结束 数码管与uart都输出自己的学号</p>
</li>
</ol>
<h5 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a><em>伪代码</em></h5>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	while()</span><br><span class="line">	&#123;</span><br><span class="line">		if(rx_ready &amp;&amp; rx_read() == &#x27;D&#x27;)</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if(check_button_nchange())</span><br><span class="line">		&#123;</span><br><span class="line">			num1 = res;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			num1 = DIPSwitch1();</span><br><span class="line">			num2 = DIPSwitch2();</span><br><span class="line">			op =  ButtonSwitch();</span><br><span class="line">		&#125;</span><br><span class="line">		res = cal(num1,num2,op);</span><br><span class="line">		if(res % 2 == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			uart_out(res);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			digittube_out(res);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(1000)</span><br><span class="line">	&#125;</span><br><span class="line">	uart_out(&lt;Your_student_id&gt;);</span><br><span class="line">	digittube_out(&lt;Your_student_id&gt;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体的处理思路与课下差别不大根据课上给出的伪代码一步一步编写即可</p>
<p>下面贴出我自己的代码供大家参考（我的uart是支持sw输出的，所以输出那里用的sw，不支持的话，可以修改为四个sb）</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">#init</span></span><br><span class="line"><span class="comment">#bote rate</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">1</span>,$<span class="number">1</span>,<span class="number">2604</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>,<span class="number">0x7f38</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>,<span class="number">0x7f3c</span>($<span class="number">0</span>)</span><br><span class="line"><span class="comment">#timer</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="number">1</span>,<span class="number">0x17d</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">1</span>,$<span class="number">1</span>,<span class="number">0x7f07</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>,<span class="number">0x7f04</span>($<span class="number">0</span>)</span><br><span class="line"><span class="comment">#allow interupt</span></span><br><span class="line"><span class="keyword">addi </span>$<span class="number">1</span>,$<span class="number">0</span>,<span class="number">0xfc01</span></span><br><span class="line"><span class="keyword">mtc0 </span>$<span class="number">1</span>,$<span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#use s4 s5 as num1 num2</span></span><br><span class="line"><span class="comment">#use s3 as lastop</span></span><br><span class="line"><span class="comment">#s1 as read word</span></span><br><span class="line"><span class="symbol">program_loop:</span></span><br><span class="line"><span class="keyword">addi </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,<span class="number">67</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">s0</span>,$<span class="built_in">t0</span>,program_out</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">t0</span>,<span class="number">0x7f68</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t0</span>,$<span class="built_in">s3</span>,reread</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">lw </span>$<span class="built_in">s4</span>,<span class="number">0x7f60</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">s5</span>,<span class="number">0x7f64</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">s3</span>,$<span class="built_in">t0</span>,$<span class="number">0</span></span><br><span class="line"><span class="symbol">reread:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">s4</span>,$<span class="number">0</span>,program_loop</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="comment">###############cal</span></span><br><span class="line"><span class="symbol">Calculator:</span> <span class="comment">#use $t5 as result</span></span><br><span class="line"><span class="keyword">add_tag:</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">andi </span>$<span class="built_in">t0</span>,$<span class="built_in">s3</span>,<span class="number">0x0001</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,<span class="keyword">sub_tag</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">add </span>$<span class="built_in">s4</span>,$<span class="built_in">s4</span>,$<span class="built_in">s5</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="number">0</span>,$<span class="number">0</span>,cal_out</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol"></span></span><br><span class="line"><span class="symbol">sub_tag:</span></span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t0</span>,$<span class="built_in">s3</span>,<span class="number">0x0002</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,<span class="keyword">mult_tag</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">sub </span>$<span class="built_in">s4</span>,$<span class="built_in">s4</span>,$<span class="built_in">s5</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="number">0</span>,$<span class="number">0</span>,cal_out</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol"></span></span><br><span class="line"><span class="symbol">mult_tag:</span></span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t0</span>,$<span class="built_in">s3</span>,<span class="number">0x0004</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,<span class="keyword">div_tag</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">mult </span>$<span class="built_in">s4</span>,$<span class="built_in">s5</span></span><br><span class="line"><span class="keyword">mflo </span>$<span class="built_in">s4</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="number">0</span>,$<span class="number">0</span>,cal_out</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol"></span></span><br><span class="line"><span class="symbol">div_tag:</span></span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t0</span>,$<span class="built_in">s3</span>,<span class="number">0x0008</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,no_tag</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">beq </span>$<span class="built_in">s5</span>,$<span class="number">0</span>,<span class="keyword">div0</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">div </span>$<span class="built_in">s4</span>,$<span class="built_in">s5</span></span><br><span class="line"><span class="keyword">mflo </span>$<span class="built_in">s4</span></span><br><span class="line"><span class="keyword">div0:</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">add </span>$<span class="built_in">s4</span>,$<span class="built_in">s4</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="number">0</span>,$<span class="number">0</span>,cal_out</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol"></span></span><br><span class="line"><span class="symbol">no_tag:</span></span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">s4</span>,$<span class="number">0</span>,$<span class="number">0</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="number">0</span>,$<span class="number">0</span>,program_loop</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment">#######Out##############</span></span><br><span class="line"><span class="symbol">cal_out:</span>         </span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t0</span>,$<span class="built_in">s4</span>,<span class="number">0x0001</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,cal_uartOut</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">cal_tubeOut:</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">s4</span>,<span class="number">0x7f50</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">beq </span>$<span class="number">0</span>,$<span class="number">0</span>,cal_endOut</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">cal_uartOut:</span></span><br><span class="line"><span class="symbol">uart_wait2:</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">t0</span>,<span class="number">0x7f34</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t0</span>,$<span class="built_in">t0</span>,<span class="number">0x0020</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,uart_wait2</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">sw </span>$<span class="built_in">s4</span>,<span class="number">0x7f30</span>($<span class="number">0</span>)</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">cal_endOut:</span></span><br><span class="line"><span class="keyword">addi </span>$<span class="built_in">s7</span>,$<span class="number">0</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">addi </span>$<span class="built_in">t9</span>,$<span class="number">0</span>,<span class="number">0x9</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">t9</span>,<span class="number">0x7f00</span>($<span class="number">0</span>)</span><br><span class="line"><span class="symbol">sleep:</span></span><br><span class="line"><span class="keyword">bne </span>$<span class="built_in">s7</span>,$<span class="number">0</span>,sleep</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">beq </span>$<span class="number">0</span>,$<span class="number">0</span>,program_loop</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment">########################</span></span><br><span class="line"><span class="symbol">program_out:</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="built_in">s0</span>,<span class="number">0x2137</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="built_in">s0</span>,$<span class="built_in">s0</span>,<span class="number">0x3016</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">uart_wait3:</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">a3</span>,<span class="number">0x7f34</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">a3</span>,$<span class="built_in">a3</span>,<span class="number">0x0020</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">a3</span>,$<span class="number">0</span>,uart_wait3</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">sw </span>$<span class="built_in">s0</span>,<span class="number">0x7f50</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">s0</span>,<span class="number">0x7f30</span>($<span class="number">0</span>)</span><br><span class="line"><span class="symbol">program_out_loop:</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="number">0</span>,$<span class="number">0</span>,program_out_loop</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#########################</span></span><br><span class="line"></span><br><span class="line">.ktext <span class="number">0x4180</span></span><br><span class="line"><span class="keyword">mfc0 </span>$<span class="built_in">k0</span>,$<span class="number">12</span></span><br><span class="line"><span class="keyword">mfc0 </span>$<span class="built_in">k1</span>,$<span class="number">13</span></span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t8</span>,$<span class="built_in">k1</span>,<span class="number">0x2000</span> <span class="comment">#UART interupt 0010 0000 0000 0000</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t8</span>,$<span class="number">0</span>,Timer_int</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#######################################</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">s0</span>,<span class="number">0x7f30</span>($<span class="number">0</span>)<span class="comment">#read in UART</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">Timer_int:</span></span><br><span class="line"><span class="keyword">andi </span>$<span class="built_in">t8</span>,$<span class="built_in">k1</span>,<span class="number">0x0400</span> <span class="comment">#Timer interupt 0000 0100 0000 0000</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t8</span>,$<span class="number">0</span>,end_exc</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">sw </span>$<span class="number">0</span>,<span class="number">0x7f00</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">s7</span>,$<span class="number">0</span>,$<span class="number">0</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">timer_endOut2:</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="number">0</span>,$<span class="number">0</span>,end_exc</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="comment">#######################</span></span><br><span class="line"><span class="symbol">end_exc:</span></span><br><span class="line"><span class="keyword">eret</span></span><br></pre></td></tr></table></figure>

<h2 id="其他可能遇到的小问题"><a href="#其他可能遇到的小问题" class="headerlink" title="其他可能遇到的小问题"></a>其他可能遇到的小问题</h2><ul>
<li>仿真与实际结果不同</li>
</ul>
<p>有可能是因为仿真的级别不够，越往下仿真级别越高，Post-Route &gt; Behavioral</p>
<p><img src="/post-image/%E4%BB%BF%E7%9C%9F%E7%BA%A7%E5%88%AB.png" alt="仿真级别"></p>
<ul>
<li>fpga没现象</li>
</ul>
<p>可以去检查一下自己ucf限制文件有没有加</p>
<ul>
<li><em><strong>fpga上的reset、以及开关、按钮都是低位有效</strong></em></li>
</ul>
<p>注意好顶层模块的处理即可，可以在顶层模块给那些低位有效的信号都翻转一下</p>
<h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><p>课下的成果示意图可以参看这位学长的<a href="https://www.bilibili.com/video/BV1YG411T7We/?is_story_h5=false&p=1&share_from=ugc&share_medium=android&share_plat=android&share_session_id=2de9b737-d2d0-4506-9670-75a2304991da&share_source=WEIXIN&share_tag=s_i&timestamp=1670510553&unique_k=f07HsLZ&code=061BmF00001RaP1txX100DXfBP1BmF0T&state=&wxfid=o7omF0XOx-AhqMvJWLzj8csoEpf8&share_times=1">视频</a><br>课上的成果图可以参看我发在视频一栏里的<a href="https://ghostonsill.github.io/video/">视频</a></p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h4 id="1、default-nettype-none宏"><a href="#1、default-nettype-none宏" class="headerlink" title="1、default_nettype none宏"></a>1、default_nettype none宏</h4><p>如果有必要，可以在自己的文件前加上宏，作用是可以方便我们检查有没有wire信号是先用再定义的，可以帮助我们发现一些隐蔽的bug</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">default_nettype</span> none</span></span><br></pre></td></tr></table></figure>

<h4 id="2、处理综合时的warning"><a href="#2、处理综合时的warning" class="headerlink" title="2、处理综合时的warning"></a>2、处理综合时的warning</h4><p>综合的时候仔细阅读综合下面的信息，将里面除了优化部分之外的warning最好都改一下，可以避免比如if 后面没else导致的锁存器</p>
<p>出现 <IM>或者<DM> remain a black box 属于正常情况</p>
<h4 id="3、调整心态，有效debug"><a href="#3、调整心态，有效debug" class="headerlink" title="3、调整心态，有效debug"></a>3、调整心态，有效debug</h4><p>写P8时，你遇到的bug有可能是硬件和软件的双重bug，要做好心理准备(bushi</p>
<p>建议第一步先测试更改通路后的cpu的功能，可以用上p7的testbench</p>
<p>测试UART的时候，可以调整rx、tx的周期然后在ISim上模拟</p>
<p>开关和数码管的测试相较而言比较简单</p>
<p>总而言之，<em><strong>一定要逐个击破</strong></em></p>
<h2 id="一点总结"><a href="#一点总结" class="headerlink" title="一点总结"></a>一点总结</h2><p>P8的任务可能是我计组课程中，最煎熬的一次，P8甚至还与我的概统期末考试撞在了同一天，下午考，晚上上机（学长爬了）</p>
<p>当时写好之后，光debug应该就耗了我两三天，中间一度试图放弃（毕竟还要复习准备期末考），不过最终还是把它写出来了，并且课上完成全部功能通过了测试。</p>
<p><em><strong>最后还是把我最好的祝福留给征战P8的同学们，祝大家好运，也希望对大家有所帮助！</strong></em></p>
]]></content>
      <categories>
        <category>计算机组成及其原理</category>
      </categories>
      <tags>
        <tag>计算机组成及其原理</tag>
        <tag>mips</tag>
        <tag>上机实验</tag>
      </tags>
  </entry>
</search>
